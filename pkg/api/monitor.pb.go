// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: monitor.proto

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HashAlgorithm int32

const (
	HashAlgorithm_SHA256     HashAlgorithm = 0
	HashAlgorithm_BLAKE2B256 HashAlgorithm = 1
)

var HashAlgorithm_name = map[int32]string{
	0: "SHA256",
	1: "BLAKE2B256",
}
var HashAlgorithm_value = map[string]int32{
	"SHA256":     0,
	"BLAKE2B256": 1,
}

func (x HashAlgorithm) String() string {
	return proto.EnumName(HashAlgorithm_name, int32(x))
}
func (HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{0}
}

type VolumeState int32

const (
	VolumeState_RESIZING VolumeState = 0
	VolumeState_READY    VolumeState = 1
	VolumeState_DELETED  VolumeState = 2
)

var VolumeState_name = map[int32]string{
	0: "RESIZING",
	1: "READY",
	2: "DELETED",
}
var VolumeState_value = map[string]int32{
	"RESIZING": 0,
	"READY":    1,
	"DELETED":  2,
}

func (x VolumeState) String() string {
	return proto.EnumName(VolumeState_name, int32(x))
}
func (VolumeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{1}
}

type ClientSettingsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientSettingsRequest) Reset()         { *m = ClientSettingsRequest{} }
func (m *ClientSettingsRequest) String() string { return proto.CompactTextString(m) }
func (*ClientSettingsRequest) ProtoMessage()    {}
func (*ClientSettingsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{0}
}
func (m *ClientSettingsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSettingsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSettingsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientSettingsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSettingsRequest.Merge(dst, src)
}
func (m *ClientSettingsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClientSettingsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSettingsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSettingsRequest proto.InternalMessageInfo

type ClientSettingsResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Settings             *ClientSettings        `protobuf:"bytes,2,opt,name=settings" json:"settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ClientSettingsResponse) Reset()         { *m = ClientSettingsResponse{} }
func (m *ClientSettingsResponse) String() string { return proto.CompactTextString(m) }
func (*ClientSettingsResponse) ProtoMessage()    {}
func (*ClientSettingsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{1}
}
func (m *ClientSettingsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSettingsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSettingsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientSettingsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSettingsResponse.Merge(dst, src)
}
func (m *ClientSettingsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClientSettingsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSettingsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSettingsResponse proto.InternalMessageInfo

func (m *ClientSettingsResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ClientSettingsResponse) GetSettings() *ClientSettings {
	if m != nil {
		return m.Settings
	}
	return nil
}

type ClientSettings struct {
	MinFillSize int32         `protobuf:"varint,1,opt,name=min_fill_size,json=minFillSize,proto3" json:"min_fill_size,omitempty"`
	HashAlgo    HashAlgorithm `protobuf:"varint,2,opt,name=hash_algo,json=hashAlgo,proto3,enum=api.HashAlgorithm" json:"hash_algo,omitempty"`
	// Types that are valid to be assigned to ChunkAlgo:
	//	*ClientSettings_Rabin
	//	*ClientSettings_Fixed
	//	*ClientSettings_Fastcdc
	ChunkAlgo            isClientSettings_ChunkAlgo `protobuf_oneof:"chunk_algo"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ClientSettings) Reset()         { *m = ClientSettings{} }
func (m *ClientSettings) String() string { return proto.CompactTextString(m) }
func (*ClientSettings) ProtoMessage()    {}
func (*ClientSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{2}
}
func (m *ClientSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSettings.Merge(dst, src)
}
func (m *ClientSettings) XXX_Size() int {
	return m.Size()
}
func (m *ClientSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSettings proto.InternalMessageInfo

type isClientSettings_ChunkAlgo interface {
	isClientSettings_ChunkAlgo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientSettings_Rabin struct {
	Rabin *RabinChunkAlgorithm `protobuf:"bytes,3,opt,name=rabin,oneof"`
}
type ClientSettings_Fixed struct {
	Fixed *FixedChunkAlgorithm `protobuf:"bytes,4,opt,name=fixed,oneof"`
}
type ClientSettings_Fastcdc struct {
	Fastcdc *FastCDCChunkAlgorithm `protobuf:"bytes,5,opt,name=fastcdc,oneof"`
}

func (*ClientSettings_Rabin) isClientSettings_ChunkAlgo()   {}
func (*ClientSettings_Fixed) isClientSettings_ChunkAlgo()   {}
func (*ClientSettings_Fastcdc) isClientSettings_ChunkAlgo() {}

func (m *ClientSettings) GetChunkAlgo() isClientSettings_ChunkAlgo {
	if m != nil {
		return m.ChunkAlgo
	}
	return nil
}

func (m *ClientSettings) GetMinFillSize() int32 {
	if m != nil {
		return m.MinFillSize
	}
	return 0
}

func (m *ClientSettings) GetHashAlgo() HashAlgorithm {
	if m != nil {
		return m.HashAlgo
	}
	return HashAlgorithm_SHA256
}

func (m *ClientSettings) GetRabin() *RabinChunkAlgorithm {
	if x, ok := m.GetChunkAlgo().(*ClientSettings_Rabin); ok {
		return x.Rabin
	}
	return nil
}

func (m *ClientSettings) GetFixed() *FixedChunkAlgorithm {
	if x, ok := m.GetChunkAlgo().(*ClientSettings_Fixed); ok {
		return x.Fixed
	}
	return nil
}

func (m *ClientSettings) GetFastcdc() *FastCDCChunkAlgorithm {
	if x, ok := m.GetChunkAlgo().(*ClientSettings_Fastcdc); ok {
		return x.Fastcdc
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientSettings) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientSettings_OneofMarshaler, _ClientSettings_OneofUnmarshaler, _ClientSettings_OneofSizer, []interface{}{
		(*ClientSettings_Rabin)(nil),
		(*ClientSettings_Fixed)(nil),
		(*ClientSettings_Fastcdc)(nil),
	}
}

func _ClientSettings_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientSettings)
	// chunk_algo
	switch x := m.ChunkAlgo.(type) {
	case *ClientSettings_Rabin:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rabin); err != nil {
			return err
		}
	case *ClientSettings_Fixed:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fixed); err != nil {
			return err
		}
	case *ClientSettings_Fastcdc:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fastcdc); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientSettings.ChunkAlgo has unexpected type %T", x)
	}
	return nil
}

func _ClientSettings_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientSettings)
	switch tag {
	case 3: // chunk_algo.rabin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RabinChunkAlgorithm)
		err := b.DecodeMessage(msg)
		m.ChunkAlgo = &ClientSettings_Rabin{msg}
		return true, err
	case 4: // chunk_algo.fixed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FixedChunkAlgorithm)
		err := b.DecodeMessage(msg)
		m.ChunkAlgo = &ClientSettings_Fixed{msg}
		return true, err
	case 5: // chunk_algo.fastcdc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FastCDCChunkAlgorithm)
		err := b.DecodeMessage(msg)
		m.ChunkAlgo = &ClientSettings_Fastcdc{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientSettings_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientSettings)
	// chunk_algo
	switch x := m.ChunkAlgo.(type) {
	case *ClientSettings_Rabin:
		s := proto.Size(x.Rabin)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientSettings_Fixed:
		s := proto.Size(x.Fixed)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientSettings_Fastcdc:
		s := proto.Size(x.Fastcdc)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RabinChunkAlgorithm struct {
	Poly                 uint64   `protobuf:"varint,1,opt,name=poly,proto3" json:"poly,omitempty"`
	MaxSize              int32    `protobuf:"varint,2,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	MinSize              int32    `protobuf:"varint,3,opt,name=min_size,json=minSize,proto3" json:"min_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RabinChunkAlgorithm) Reset()         { *m = RabinChunkAlgorithm{} }
func (m *RabinChunkAlgorithm) String() string { return proto.CompactTextString(m) }
func (*RabinChunkAlgorithm) ProtoMessage()    {}
func (*RabinChunkAlgorithm) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{3}
}
func (m *RabinChunkAlgorithm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RabinChunkAlgorithm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RabinChunkAlgorithm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RabinChunkAlgorithm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RabinChunkAlgorithm.Merge(dst, src)
}
func (m *RabinChunkAlgorithm) XXX_Size() int {
	return m.Size()
}
func (m *RabinChunkAlgorithm) XXX_DiscardUnknown() {
	xxx_messageInfo_RabinChunkAlgorithm.DiscardUnknown(m)
}

var xxx_messageInfo_RabinChunkAlgorithm proto.InternalMessageInfo

func (m *RabinChunkAlgorithm) GetPoly() uint64 {
	if m != nil {
		return m.Poly
	}
	return 0
}

func (m *RabinChunkAlgorithm) GetMaxSize() int32 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

func (m *RabinChunkAlgorithm) GetMinSize() int32 {
	if m != nil {
		return m.MinSize
	}
	return 0
}

type FixedChunkAlgorithm struct {
	MaxSize              int32    `protobuf:"varint,1,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FixedChunkAlgorithm) Reset()         { *m = FixedChunkAlgorithm{} }
func (m *FixedChunkAlgorithm) String() string { return proto.CompactTextString(m) }
func (*FixedChunkAlgorithm) ProtoMessage()    {}
func (*FixedChunkAlgorithm) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{4}
}
func (m *FixedChunkAlgorithm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FixedChunkAlgorithm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FixedChunkAlgorithm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FixedChunkAlgorithm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FixedChunkAlgorithm.Merge(dst, src)
}
func (m *FixedChunkAlgorithm) XXX_Size() int {
	return m.Size()
}
func (m *FixedChunkAlgorithm) XXX_DiscardUnknown() {
	xxx_messageInfo_FixedChunkAlgorithm.DiscardUnknown(m)
}

var xxx_messageInfo_FixedChunkAlgorithm proto.InternalMessageInfo

func (m *FixedChunkAlgorithm) GetMaxSize() int32 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

type FastCDCChunkAlgorithm struct {
	MaxSize              int32    `protobuf:"varint,1,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	MinSize              int32    `protobuf:"varint,2,opt,name=min_size,json=minSize,proto3" json:"min_size,omitempty"`
	AvgSize              int32    `protobuf:"varint,3,opt,name=avg_size,json=avgSize,proto3" json:"avg_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FastCDCChunkAlgorithm) Reset()         { *m = FastCDCChunkAlgorithm{} }
func (m *FastCDCChunkAlgorithm) String() string { return proto.CompactTextString(m) }
func (*FastCDCChunkAlgorithm) ProtoMessage()    {}
func (*FastCDCChunkAlgorithm) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{5}
}
func (m *FastCDCChunkAlgorithm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FastCDCChunkAlgorithm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FastCDCChunkAlgorithm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FastCDCChunkAlgorithm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FastCDCChunkAlgorithm.Merge(dst, src)
}
func (m *FastCDCChunkAlgorithm) XXX_Size() int {
	return m.Size()
}
func (m *FastCDCChunkAlgorithm) XXX_DiscardUnknown() {
	xxx_messageInfo_FastCDCChunkAlgorithm.DiscardUnknown(m)
}

var xxx_messageInfo_FastCDCChunkAlgorithm proto.InternalMessageInfo

func (m *FastCDCChunkAlgorithm) GetMaxSize() int32 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

func (m *FastCDCChunkAlgorithm) GetMinSize() int32 {
	if m != nil {
		return m.MinSize
	}
	return 0
}

func (m *FastCDCChunkAlgorithm) GetAvgSize() int32 {
	if m != nil {
		return m.AvgSize
	}
	return 0
}

type ServerSettingsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerSettingsRequest) Reset()         { *m = ServerSettingsRequest{} }
func (m *ServerSettingsRequest) String() string { return proto.CompactTextString(m) }
func (*ServerSettingsRequest) ProtoMessage()    {}
func (*ServerSettingsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{6}
}
func (m *ServerSettingsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerSettingsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerSettingsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServerSettingsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerSettingsRequest.Merge(dst, src)
}
func (m *ServerSettingsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServerSettingsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerSettingsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerSettingsRequest proto.InternalMessageInfo

type ServerSettingsResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Settings             *ServerSettings        `protobuf:"bytes,2,opt,name=settings" json:"settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ServerSettingsResponse) Reset()         { *m = ServerSettingsResponse{} }
func (m *ServerSettingsResponse) String() string { return proto.CompactTextString(m) }
func (*ServerSettingsResponse) ProtoMessage()    {}
func (*ServerSettingsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{7}
}
func (m *ServerSettingsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerSettingsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerSettingsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServerSettingsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerSettingsResponse.Merge(dst, src)
}
func (m *ServerSettingsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ServerSettingsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerSettingsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerSettingsResponse proto.InternalMessageInfo

func (m *ServerSettingsResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ServerSettingsResponse) GetSettings() *ServerSettings {
	if m != nil {
		return m.Settings
	}
	return nil
}

type ServerSettings struct {
	ShardSize            int64    `protobuf:"varint,1,opt,name=shard_size,json=shardSize,proto3" json:"shard_size,omitempty"`
	ShardEntriesPerSlice int32    `protobuf:"varint,2,opt,name=shard_entries_per_slice,json=shardEntriesPerSlice,proto3" json:"shard_entries_per_slice,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerSettings) Reset()         { *m = ServerSettings{} }
func (m *ServerSettings) String() string { return proto.CompactTextString(m) }
func (*ServerSettings) ProtoMessage()    {}
func (*ServerSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{8}
}
func (m *ServerSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServerSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerSettings.Merge(dst, src)
}
func (m *ServerSettings) XXX_Size() int {
	return m.Size()
}
func (m *ServerSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ServerSettings proto.InternalMessageInfo

func (m *ServerSettings) GetShardSize() int64 {
	if m != nil {
		return m.ShardSize
	}
	return 0
}

func (m *ServerSettings) GetShardEntriesPerSlice() int32 {
	if m != nil {
		return m.ShardEntriesPerSlice
	}
	return 0
}

type GetBlockStoresRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockStoresRequest) Reset()         { *m = GetBlockStoresRequest{} }
func (m *GetBlockStoresRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockStoresRequest) ProtoMessage()    {}
func (*GetBlockStoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{9}
}
func (m *GetBlockStoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockStoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockStoresRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBlockStoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockStoresRequest.Merge(dst, src)
}
func (m *GetBlockStoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockStoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockStoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockStoresRequest proto.InternalMessageInfo

type GetBlockStoresResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Data                 *NodeReplicaSets       `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetBlockStoresResponse) Reset()         { *m = GetBlockStoresResponse{} }
func (m *GetBlockStoresResponse) String() string { return proto.CompactTextString(m) }
func (*GetBlockStoresResponse) ProtoMessage()    {}
func (*GetBlockStoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{10}
}
func (m *GetBlockStoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockStoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockStoresResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBlockStoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockStoresResponse.Merge(dst, src)
}
func (m *GetBlockStoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockStoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockStoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockStoresResponse proto.InternalMessageInfo

func (m *GetBlockStoresResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetBlockStoresResponse) GetData() *NodeReplicaSets {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetIndexStoresRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetIndexStoresRequest) Reset()         { *m = GetIndexStoresRequest{} }
func (m *GetIndexStoresRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexStoresRequest) ProtoMessage()    {}
func (*GetIndexStoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{11}
}
func (m *GetIndexStoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexStoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexStoresRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetIndexStoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexStoresRequest.Merge(dst, src)
}
func (m *GetIndexStoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexStoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexStoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexStoresRequest proto.InternalMessageInfo

type GetIndexStoresResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Data                 *NodeReplicaSets       `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetIndexStoresResponse) Reset()         { *m = GetIndexStoresResponse{} }
func (m *GetIndexStoresResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexStoresResponse) ProtoMessage()    {}
func (*GetIndexStoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{12}
}
func (m *GetIndexStoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexStoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexStoresResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetIndexStoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexStoresResponse.Merge(dst, src)
}
func (m *GetIndexStoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexStoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexStoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexStoresResponse proto.InternalMessageInfo

func (m *GetIndexStoresResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetIndexStoresResponse) GetData() *NodeReplicaSets {
	if m != nil {
		return m.Data
	}
	return nil
}

type NodeReplicaSets struct {
	Sets                 []*NodeReplicaSet `protobuf:"bytes,1,rep,name=sets" json:"sets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *NodeReplicaSets) Reset()         { *m = NodeReplicaSets{} }
func (m *NodeReplicaSets) String() string { return proto.CompactTextString(m) }
func (*NodeReplicaSets) ProtoMessage()    {}
func (*NodeReplicaSets) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{13}
}
func (m *NodeReplicaSets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeReplicaSets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeReplicaSets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeReplicaSets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeReplicaSets.Merge(dst, src)
}
func (m *NodeReplicaSets) XXX_Size() int {
	return m.Size()
}
func (m *NodeReplicaSets) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeReplicaSets.DiscardUnknown(m)
}

var xxx_messageInfo_NodeReplicaSets proto.InternalMessageInfo

func (m *NodeReplicaSets) GetSets() []*NodeReplicaSet {
	if m != nil {
		return m.Sets
	}
	return nil
}

type NodeReplicaSet struct {
	Nodes                []*Node  `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeReplicaSet) Reset()         { *m = NodeReplicaSet{} }
func (m *NodeReplicaSet) String() string { return proto.CompactTextString(m) }
func (*NodeReplicaSet) ProtoMessage()    {}
func (*NodeReplicaSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{14}
}
func (m *NodeReplicaSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeReplicaSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeReplicaSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeReplicaSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeReplicaSet.Merge(dst, src)
}
func (m *NodeReplicaSet) XXX_Size() int {
	return m.Size()
}
func (m *NodeReplicaSet) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeReplicaSet.DiscardUnknown(m)
}

var xxx_messageInfo_NodeReplicaSet proto.InternalMessageInfo

func (m *NodeReplicaSet) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type Node struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Primary              bool     `protobuf:"varint,3,opt,name=primary,proto3" json:"primary,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{15}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(dst, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

type GetVolumesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVolumesRequest) Reset()         { *m = GetVolumesRequest{} }
func (m *GetVolumesRequest) String() string { return proto.CompactTextString(m) }
func (*GetVolumesRequest) ProtoMessage()    {}
func (*GetVolumesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{16}
}
func (m *GetVolumesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVolumesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVolumesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetVolumesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVolumesRequest.Merge(dst, src)
}
func (m *GetVolumesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetVolumesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVolumesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVolumesRequest proto.InternalMessageInfo

type GetVolumesResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Volumes              []*Volume              `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetVolumesResponse) Reset()         { *m = GetVolumesResponse{} }
func (m *GetVolumesResponse) String() string { return proto.CompactTextString(m) }
func (*GetVolumesResponse) ProtoMessage()    {}
func (*GetVolumesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{17}
}
func (m *GetVolumesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVolumesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVolumesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetVolumesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVolumesResponse.Merge(dst, src)
}
func (m *GetVolumesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetVolumesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVolumesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetVolumesResponse proto.InternalMessageInfo

func (m *GetVolumesResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetVolumesResponse) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type ModifyVolumeRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Shards               int64    `protobuf:"varint,2,opt,name=shards,proto3" json:"shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModifyVolumeRequest) Reset()         { *m = ModifyVolumeRequest{} }
func (m *ModifyVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*ModifyVolumeRequest) ProtoMessage()    {}
func (*ModifyVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{18}
}
func (m *ModifyVolumeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyVolumeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModifyVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyVolumeRequest.Merge(dst, src)
}
func (m *ModifyVolumeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyVolumeRequest proto.InternalMessageInfo

func (m *ModifyVolumeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModifyVolumeRequest) GetShards() int64 {
	if m != nil {
		return m.Shards
	}
	return 0
}

type ModifyVolumeResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ModifyVolumeResponse) Reset()         { *m = ModifyVolumeResponse{} }
func (m *ModifyVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*ModifyVolumeResponse) ProtoMessage()    {}
func (*ModifyVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{19}
}
func (m *ModifyVolumeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyVolumeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModifyVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyVolumeResponse.Merge(dst, src)
}
func (m *ModifyVolumeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ModifyVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyVolumeResponse proto.InternalMessageInfo

func (m *ModifyVolumeResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type WatchVolumesRequest struct {
	Header               *WatchRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *WatchVolumesRequest) Reset()         { *m = WatchVolumesRequest{} }
func (m *WatchVolumesRequest) String() string { return proto.CompactTextString(m) }
func (*WatchVolumesRequest) ProtoMessage()    {}
func (*WatchVolumesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{20}
}
func (m *WatchVolumesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchVolumesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchVolumesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WatchVolumesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchVolumesRequest.Merge(dst, src)
}
func (m *WatchVolumesRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchVolumesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchVolumesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchVolumesRequest proto.InternalMessageInfo

func (m *WatchVolumesRequest) GetHeader() *WatchRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type WatchVolumesResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Volumes              []*Volume              `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *WatchVolumesResponse) Reset()         { *m = WatchVolumesResponse{} }
func (m *WatchVolumesResponse) String() string { return proto.CompactTextString(m) }
func (*WatchVolumesResponse) ProtoMessage()    {}
func (*WatchVolumesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{21}
}
func (m *WatchVolumesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchVolumesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchVolumesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WatchVolumesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchVolumesResponse.Merge(dst, src)
}
func (m *WatchVolumesResponse) XXX_Size() int {
	return m.Size()
}
func (m *WatchVolumesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchVolumesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WatchVolumesResponse proto.InternalMessageInfo

func (m *WatchVolumesResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *WatchVolumesResponse) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type UpdateShardsRequest struct {
	VolumeName           string   `protobuf:"bytes,1,opt,name=volume_name,json=volumeName,proto3" json:"volume_name,omitempty"`
	AddedShards          []int64  `protobuf:"varint,2,rep,packed,name=added_shards,json=addedShards" json:"added_shards,omitempty"`
	RemovedShards        []int64  `protobuf:"varint,3,rep,packed,name=removed_shards,json=removedShards" json:"removed_shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateShardsRequest) Reset()         { *m = UpdateShardsRequest{} }
func (m *UpdateShardsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateShardsRequest) ProtoMessage()    {}
func (*UpdateShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{22}
}
func (m *UpdateShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardsRequest.Merge(dst, src)
}
func (m *UpdateShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardsRequest proto.InternalMessageInfo

func (m *UpdateShardsRequest) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

func (m *UpdateShardsRequest) GetAddedShards() []int64 {
	if m != nil {
		return m.AddedShards
	}
	return nil
}

func (m *UpdateShardsRequest) GetRemovedShards() []int64 {
	if m != nil {
		return m.RemovedShards
	}
	return nil
}

type UpdateShardsResponse struct {
	Header               *MonitorResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateShardsResponse) Reset()         { *m = UpdateShardsResponse{} }
func (m *UpdateShardsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateShardsResponse) ProtoMessage()    {}
func (*UpdateShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{23}
}
func (m *UpdateShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateShardsResponse.Merge(dst, src)
}
func (m *UpdateShardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateShardsResponse proto.InternalMessageInfo

func (m *UpdateShardsResponse) GetHeader() *MonitorResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type Volume struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State                VolumeState `protobuf:"varint,2,opt,name=state,proto3,enum=api.VolumeState" json:"state,omitempty"`
	Shards               int64       `protobuf:"varint,3,opt,name=shards,proto3" json:"shards,omitempty"`
	RequestedShards      int64       `protobuf:"varint,4,opt,name=requested_shards,json=requestedShards,proto3" json:"requested_shards,omitempty"`
	CurrentShards        []int64     `protobuf:"varint,5,rep,packed,name=current_shards,json=currentShards" json:"current_shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}
func (*Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{24}
}
func (m *Volume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Volume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Volume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Volume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Volume.Merge(dst, src)
}
func (m *Volume) XXX_Size() int {
	return m.Size()
}
func (m *Volume) XXX_DiscardUnknown() {
	xxx_messageInfo_Volume.DiscardUnknown(m)
}

var xxx_messageInfo_Volume proto.InternalMessageInfo

func (m *Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume) GetState() VolumeState {
	if m != nil {
		return m.State
	}
	return VolumeState_RESIZING
}

func (m *Volume) GetShards() int64 {
	if m != nil {
		return m.Shards
	}
	return 0
}

func (m *Volume) GetRequestedShards() int64 {
	if m != nil {
		return m.RequestedShards
	}
	return 0
}

func (m *Volume) GetCurrentShards() []int64 {
	if m != nil {
		return m.CurrentShards
	}
	return nil
}

type MonitorResponseHeader struct {
	Revision             int64    `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	Error                int32    `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
	ErrorMsg             string   `protobuf:"bytes,3,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MonitorResponseHeader) Reset()         { *m = MonitorResponseHeader{} }
func (m *MonitorResponseHeader) String() string { return proto.CompactTextString(m) }
func (*MonitorResponseHeader) ProtoMessage()    {}
func (*MonitorResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{25}
}
func (m *MonitorResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitorResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitorResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MonitorResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitorResponseHeader.Merge(dst, src)
}
func (m *MonitorResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *MonitorResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitorResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MonitorResponseHeader proto.InternalMessageInfo

func (m *MonitorResponseHeader) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *MonitorResponseHeader) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

func (m *MonitorResponseHeader) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

type WatchRequestHeader struct {
	StartRevision        int64    `protobuf:"varint,1,opt,name=start_revision,json=startRevision,proto3" json:"start_revision,omitempty"`
	End                  bool     `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WatchRequestHeader) Reset()         { *m = WatchRequestHeader{} }
func (m *WatchRequestHeader) String() string { return proto.CompactTextString(m) }
func (*WatchRequestHeader) ProtoMessage()    {}
func (*WatchRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_monitor_4b8c2940e2de8636, []int{26}
}
func (m *WatchRequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchRequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WatchRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchRequestHeader.Merge(dst, src)
}
func (m *WatchRequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *WatchRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_WatchRequestHeader proto.InternalMessageInfo

func (m *WatchRequestHeader) GetStartRevision() int64 {
	if m != nil {
		return m.StartRevision
	}
	return 0
}

func (m *WatchRequestHeader) GetEnd() bool {
	if m != nil {
		return m.End
	}
	return false
}

func init() {
	proto.RegisterType((*ClientSettingsRequest)(nil), "api.ClientSettingsRequest")
	proto.RegisterType((*ClientSettingsResponse)(nil), "api.ClientSettingsResponse")
	proto.RegisterType((*ClientSettings)(nil), "api.ClientSettings")
	proto.RegisterType((*RabinChunkAlgorithm)(nil), "api.RabinChunkAlgorithm")
	proto.RegisterType((*FixedChunkAlgorithm)(nil), "api.FixedChunkAlgorithm")
	proto.RegisterType((*FastCDCChunkAlgorithm)(nil), "api.FastCDCChunkAlgorithm")
	proto.RegisterType((*ServerSettingsRequest)(nil), "api.ServerSettingsRequest")
	proto.RegisterType((*ServerSettingsResponse)(nil), "api.ServerSettingsResponse")
	proto.RegisterType((*ServerSettings)(nil), "api.ServerSettings")
	proto.RegisterType((*GetBlockStoresRequest)(nil), "api.GetBlockStoresRequest")
	proto.RegisterType((*GetBlockStoresResponse)(nil), "api.GetBlockStoresResponse")
	proto.RegisterType((*GetIndexStoresRequest)(nil), "api.GetIndexStoresRequest")
	proto.RegisterType((*GetIndexStoresResponse)(nil), "api.GetIndexStoresResponse")
	proto.RegisterType((*NodeReplicaSets)(nil), "api.NodeReplicaSets")
	proto.RegisterType((*NodeReplicaSet)(nil), "api.NodeReplicaSet")
	proto.RegisterType((*Node)(nil), "api.Node")
	proto.RegisterType((*GetVolumesRequest)(nil), "api.GetVolumesRequest")
	proto.RegisterType((*GetVolumesResponse)(nil), "api.GetVolumesResponse")
	proto.RegisterType((*ModifyVolumeRequest)(nil), "api.ModifyVolumeRequest")
	proto.RegisterType((*ModifyVolumeResponse)(nil), "api.ModifyVolumeResponse")
	proto.RegisterType((*WatchVolumesRequest)(nil), "api.WatchVolumesRequest")
	proto.RegisterType((*WatchVolumesResponse)(nil), "api.WatchVolumesResponse")
	proto.RegisterType((*UpdateShardsRequest)(nil), "api.UpdateShardsRequest")
	proto.RegisterType((*UpdateShardsResponse)(nil), "api.UpdateShardsResponse")
	proto.RegisterType((*Volume)(nil), "api.Volume")
	proto.RegisterType((*MonitorResponseHeader)(nil), "api.MonitorResponseHeader")
	proto.RegisterType((*WatchRequestHeader)(nil), "api.WatchRequestHeader")
	proto.RegisterEnum("api.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	proto.RegisterEnum("api.VolumeState", VolumeState_name, VolumeState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SettingsClient is the client API for Settings service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SettingsClient interface {
	GetClientSettings(ctx context.Context, in *ClientSettingsRequest, opts ...grpc.CallOption) (*ClientSettingsResponse, error)
	GetServerSettings(ctx context.Context, in *ServerSettingsRequest, opts ...grpc.CallOption) (*ServerSettingsResponse, error)
}

type settingsClient struct {
	cc *grpc.ClientConn
}

func NewSettingsClient(cc *grpc.ClientConn) SettingsClient {
	return &settingsClient{cc}
}

func (c *settingsClient) GetClientSettings(ctx context.Context, in *ClientSettingsRequest, opts ...grpc.CallOption) (*ClientSettingsResponse, error) {
	out := new(ClientSettingsResponse)
	err := c.cc.Invoke(ctx, "/api.Settings/GetClientSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsClient) GetServerSettings(ctx context.Context, in *ServerSettingsRequest, opts ...grpc.CallOption) (*ServerSettingsResponse, error) {
	out := new(ServerSettingsResponse)
	err := c.cc.Invoke(ctx, "/api.Settings/GetServerSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingsServer is the server API for Settings service.
type SettingsServer interface {
	GetClientSettings(context.Context, *ClientSettingsRequest) (*ClientSettingsResponse, error)
	GetServerSettings(context.Context, *ServerSettingsRequest) (*ServerSettingsResponse, error)
}

func RegisterSettingsServer(s *grpc.Server, srv SettingsServer) {
	s.RegisterService(&_Settings_serviceDesc, srv)
}

func _Settings_GetClientSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetClientSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Settings/GetClientSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetClientSettings(ctx, req.(*ClientSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Settings_GetServerSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServer).GetServerSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Settings/GetServerSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServer).GetServerSettings(ctx, req.(*ServerSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Settings_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Settings",
	HandlerType: (*SettingsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClientSettings",
			Handler:    _Settings_GetClientSettings_Handler,
		},
		{
			MethodName: "GetServerSettings",
			Handler:    _Settings_GetServerSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "monitor.proto",
}

// NodesClient is the client API for Nodes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodesClient interface {
	GetBlockStores(ctx context.Context, in *GetBlockStoresRequest, opts ...grpc.CallOption) (*GetBlockStoresResponse, error)
	GetIndexStores(ctx context.Context, in *GetIndexStoresRequest, opts ...grpc.CallOption) (*GetIndexStoresResponse, error)
}

type nodesClient struct {
	cc *grpc.ClientConn
}

func NewNodesClient(cc *grpc.ClientConn) NodesClient {
	return &nodesClient{cc}
}

func (c *nodesClient) GetBlockStores(ctx context.Context, in *GetBlockStoresRequest, opts ...grpc.CallOption) (*GetBlockStoresResponse, error) {
	out := new(GetBlockStoresResponse)
	err := c.cc.Invoke(ctx, "/api.Nodes/GetBlockStores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodesClient) GetIndexStores(ctx context.Context, in *GetIndexStoresRequest, opts ...grpc.CallOption) (*GetIndexStoresResponse, error) {
	out := new(GetIndexStoresResponse)
	err := c.cc.Invoke(ctx, "/api.Nodes/GetIndexStores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodesServer is the server API for Nodes service.
type NodesServer interface {
	GetBlockStores(context.Context, *GetBlockStoresRequest) (*GetBlockStoresResponse, error)
	GetIndexStores(context.Context, *GetIndexStoresRequest) (*GetIndexStoresResponse, error)
}

func RegisterNodesServer(s *grpc.Server, srv NodesServer) {
	s.RegisterService(&_Nodes_serviceDesc, srv)
}

func _Nodes_GetBlockStores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockStoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodesServer).GetBlockStores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Nodes/GetBlockStores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodesServer).GetBlockStores(ctx, req.(*GetBlockStoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nodes_GetIndexStores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexStoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodesServer).GetIndexStores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Nodes/GetIndexStores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodesServer).GetIndexStores(ctx, req.(*GetIndexStoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nodes_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Nodes",
	HandlerType: (*NodesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockStores",
			Handler:    _Nodes_GetBlockStores_Handler,
		},
		{
			MethodName: "GetIndexStores",
			Handler:    _Nodes_GetIndexStores_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "monitor.proto",
}

// VolumesClient is the client API for Volumes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VolumesClient interface {
	Get(ctx context.Context, in *GetVolumesRequest, opts ...grpc.CallOption) (*GetVolumesResponse, error)
	Modify(ctx context.Context, in *ModifyVolumeRequest, opts ...grpc.CallOption) (*ModifyVolumeResponse, error)
	Watch(ctx context.Context, opts ...grpc.CallOption) (Volumes_WatchClient, error)
	UpdateShards(ctx context.Context, in *UpdateShardsRequest, opts ...grpc.CallOption) (*UpdateShardsResponse, error)
}

type volumesClient struct {
	cc *grpc.ClientConn
}

func NewVolumesClient(cc *grpc.ClientConn) VolumesClient {
	return &volumesClient{cc}
}

func (c *volumesClient) Get(ctx context.Context, in *GetVolumesRequest, opts ...grpc.CallOption) (*GetVolumesResponse, error) {
	out := new(GetVolumesResponse)
	err := c.cc.Invoke(ctx, "/api.Volumes/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumesClient) Modify(ctx context.Context, in *ModifyVolumeRequest, opts ...grpc.CallOption) (*ModifyVolumeResponse, error) {
	out := new(ModifyVolumeResponse)
	err := c.cc.Invoke(ctx, "/api.Volumes/Modify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumesClient) Watch(ctx context.Context, opts ...grpc.CallOption) (Volumes_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Volumes_serviceDesc.Streams[0], "/api.Volumes/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &volumesWatchClient{stream}
	return x, nil
}

type Volumes_WatchClient interface {
	Send(*WatchVolumesRequest) error
	Recv() (*WatchVolumesResponse, error)
	grpc.ClientStream
}

type volumesWatchClient struct {
	grpc.ClientStream
}

func (x *volumesWatchClient) Send(m *WatchVolumesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *volumesWatchClient) Recv() (*WatchVolumesResponse, error) {
	m := new(WatchVolumesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *volumesClient) UpdateShards(ctx context.Context, in *UpdateShardsRequest, opts ...grpc.CallOption) (*UpdateShardsResponse, error) {
	out := new(UpdateShardsResponse)
	err := c.cc.Invoke(ctx, "/api.Volumes/UpdateShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VolumesServer is the server API for Volumes service.
type VolumesServer interface {
	Get(context.Context, *GetVolumesRequest) (*GetVolumesResponse, error)
	Modify(context.Context, *ModifyVolumeRequest) (*ModifyVolumeResponse, error)
	Watch(Volumes_WatchServer) error
	UpdateShards(context.Context, *UpdateShardsRequest) (*UpdateShardsResponse, error)
}

func RegisterVolumesServer(s *grpc.Server, srv VolumesServer) {
	s.RegisterService(&_Volumes_serviceDesc, srv)
}

func _Volumes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVolumesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Volumes/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumesServer).Get(ctx, req.(*GetVolumesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volumes_Modify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumesServer).Modify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Volumes/Modify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumesServer).Modify(ctx, req.(*ModifyVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Volumes_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VolumesServer).Watch(&volumesWatchServer{stream})
}

type Volumes_WatchServer interface {
	Send(*WatchVolumesResponse) error
	Recv() (*WatchVolumesRequest, error)
	grpc.ServerStream
}

type volumesWatchServer struct {
	grpc.ServerStream
}

func (x *volumesWatchServer) Send(m *WatchVolumesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *volumesWatchServer) Recv() (*WatchVolumesRequest, error) {
	m := new(WatchVolumesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Volumes_UpdateShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumesServer).UpdateShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Volumes/UpdateShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumesServer).UpdateShards(ctx, req.(*UpdateShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Volumes_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Volumes",
	HandlerType: (*VolumesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Volumes_Get_Handler,
		},
		{
			MethodName: "Modify",
			Handler:    _Volumes_Modify_Handler,
		},
		{
			MethodName: "UpdateShards",
			Handler:    _Volumes_UpdateShards_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Volumes_Watch_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "monitor.proto",
}

func (m *ClientSettingsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSettingsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientSettingsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSettingsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n1, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Settings != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Settings.Size()))
		n2, err := m.Settings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinFillSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.MinFillSize))
	}
	if m.HashAlgo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.HashAlgo))
	}
	if m.ChunkAlgo != nil {
		nn3, err := m.ChunkAlgo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientSettings_Rabin) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rabin != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Rabin.Size()))
		n4, err := m.Rabin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *ClientSettings_Fixed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Fixed != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Fixed.Size()))
		n5, err := m.Fixed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *ClientSettings_Fastcdc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Fastcdc != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Fastcdc.Size()))
		n6, err := m.Fastcdc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *RabinChunkAlgorithm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RabinChunkAlgorithm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Poly != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Poly))
	}
	if m.MaxSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.MaxSize))
	}
	if m.MinSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.MinSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FixedChunkAlgorithm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FixedChunkAlgorithm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.MaxSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FastCDCChunkAlgorithm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FastCDCChunkAlgorithm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.MaxSize))
	}
	if m.MinSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.MinSize))
	}
	if m.AvgSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.AvgSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerSettingsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerSettingsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerSettingsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerSettingsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n7, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Settings != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Settings.Size()))
		n8, err := m.Settings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.ShardSize))
	}
	if m.ShardEntriesPerSlice != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.ShardEntriesPerSlice))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetBlockStoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockStoresRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetBlockStoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockStoresResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n9, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Data.Size()))
		n10, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetIndexStoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexStoresRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetIndexStoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexStoresResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n11, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Data.Size()))
		n12, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeReplicaSets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeReplicaSets) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, msg := range m.Sets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeReplicaSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeReplicaSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Primary {
		dAtA[i] = 0x18
		i++
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetVolumesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVolumesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetVolumesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVolumesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n13, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Shards != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Shards))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ModifyVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n14, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WatchVolumesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchVolumesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n15, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WatchVolumesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchVolumesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n16, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(len(m.VolumeName)))
		i += copy(dAtA[i:], m.VolumeName)
	}
	if len(m.AddedShards) > 0 {
		dAtA18 := make([]byte, len(m.AddedShards)*10)
		var j17 int
		for _, num1 := range m.AddedShards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.RemovedShards) > 0 {
		dAtA20 := make([]byte, len(m.RemovedShards)*10)
		var j19 int
		for _, num1 := range m.RemovedShards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Header.Size()))
		n21, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Volume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.State))
	}
	if m.Shards != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Shards))
	}
	if m.RequestedShards != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.RequestedShards))
	}
	if len(m.CurrentShards) > 0 {
		dAtA23 := make([]byte, len(m.CurrentShards)*10)
		var j22 int
		for _, num1 := range m.CurrentShards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MonitorResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitorResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Revision))
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.Error))
	}
	if len(m.ErrorMsg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(len(m.ErrorMsg)))
		i += copy(dAtA[i:], m.ErrorMsg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WatchRequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchRequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartRevision != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMonitor(dAtA, i, uint64(m.StartRevision))
	}
	if m.End {
		dAtA[i] = 0x10
		i++
		if m.End {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMonitor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClientSettingsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientSettingsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinFillSize != 0 {
		n += 1 + sovMonitor(uint64(m.MinFillSize))
	}
	if m.HashAlgo != 0 {
		n += 1 + sovMonitor(uint64(m.HashAlgo))
	}
	if m.ChunkAlgo != nil {
		n += m.ChunkAlgo.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientSettings_Rabin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rabin != nil {
		l = m.Rabin.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	return n
}
func (m *ClientSettings_Fixed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fixed != nil {
		l = m.Fixed.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	return n
}
func (m *ClientSettings_Fastcdc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fastcdc != nil {
		l = m.Fastcdc.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	return n
}
func (m *RabinChunkAlgorithm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Poly != 0 {
		n += 1 + sovMonitor(uint64(m.Poly))
	}
	if m.MaxSize != 0 {
		n += 1 + sovMonitor(uint64(m.MaxSize))
	}
	if m.MinSize != 0 {
		n += 1 + sovMonitor(uint64(m.MinSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FixedChunkAlgorithm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxSize != 0 {
		n += 1 + sovMonitor(uint64(m.MaxSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FastCDCChunkAlgorithm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxSize != 0 {
		n += 1 + sovMonitor(uint64(m.MaxSize))
	}
	if m.MinSize != 0 {
		n += 1 + sovMonitor(uint64(m.MinSize))
	}
	if m.AvgSize != 0 {
		n += 1 + sovMonitor(uint64(m.AvgSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerSettingsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerSettingsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.Settings != nil {
		l = m.Settings.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardSize != 0 {
		n += 1 + sovMonitor(uint64(m.ShardSize))
	}
	if m.ShardEntriesPerSlice != 0 {
		n += 1 + sovMonitor(uint64(m.ShardEntriesPerSlice))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockStoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockStoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetIndexStoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetIndexStoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeReplicaSets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, e := range m.Sets {
			l = e.Size()
			n += 1 + l + sovMonitor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeReplicaSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovMonitor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMonitor(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVolumesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVolumesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovMonitor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyVolumeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.Shards != 0 {
		n += 1 + sovMonitor(uint64(m.Shards))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyVolumeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchVolumesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchVolumesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovMonitor(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovMonitor(uint64(l))
	}
	if len(m.AddedShards) > 0 {
		l = 0
		for _, e := range m.AddedShards {
			l += sovMonitor(uint64(e))
		}
		n += 1 + sovMonitor(uint64(l)) + l
	}
	if len(m.RemovedShards) > 0 {
		l = 0
		for _, e := range m.RemovedShards {
			l += sovMonitor(uint64(e))
		}
		n += 1 + sovMonitor(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateShardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Volume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMonitor(uint64(m.State))
	}
	if m.Shards != 0 {
		n += 1 + sovMonitor(uint64(m.Shards))
	}
	if m.RequestedShards != 0 {
		n += 1 + sovMonitor(uint64(m.RequestedShards))
	}
	if len(m.CurrentShards) > 0 {
		l = 0
		for _, e := range m.CurrentShards {
			l += sovMonitor(uint64(e))
		}
		n += 1 + sovMonitor(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitorResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovMonitor(uint64(m.Revision))
	}
	if m.Error != 0 {
		n += 1 + sovMonitor(uint64(m.Error))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovMonitor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchRequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartRevision != 0 {
		n += 1 + sovMonitor(uint64(m.StartRevision))
	}
	if m.End {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMonitor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMonitor(x uint64) (n int) {
	return sovMonitor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientSettingsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSettingsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSettingsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientSettingsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSettingsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSettingsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &ClientSettings{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFillSize", wireType)
			}
			m.MinFillSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinFillSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashAlgo", wireType)
			}
			m.HashAlgo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashAlgo |= (HashAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rabin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RabinChunkAlgorithm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChunkAlgo = &ClientSettings_Rabin{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FixedChunkAlgorithm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChunkAlgo = &ClientSettings_Fixed{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fastcdc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FastCDCChunkAlgorithm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChunkAlgo = &ClientSettings_Fastcdc{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RabinChunkAlgorithm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RabinChunkAlgorithm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RabinChunkAlgorithm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poly", wireType)
			}
			m.Poly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Poly |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSize", wireType)
			}
			m.MinSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FixedChunkAlgorithm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FixedChunkAlgorithm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FixedChunkAlgorithm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FastCDCChunkAlgorithm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FastCDCChunkAlgorithm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FastCDCChunkAlgorithm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSize", wireType)
			}
			m.MinSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgSize", wireType)
			}
			m.AvgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvgSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerSettingsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerSettingsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerSettingsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerSettingsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerSettingsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerSettingsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settings == nil {
				m.Settings = &ServerSettings{}
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardSize", wireType)
			}
			m.ShardSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEntriesPerSlice", wireType)
			}
			m.ShardEntriesPerSlice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardEntriesPerSlice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockStoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockStoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockStoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockStoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockStoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockStoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &NodeReplicaSets{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexStoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexStoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexStoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexStoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexStoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexStoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &NodeReplicaSets{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeReplicaSets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeReplicaSets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeReplicaSets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sets = append(m.Sets, &NodeReplicaSet{})
			if err := m.Sets[len(m.Sets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeReplicaSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeReplicaSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeReplicaSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVolumesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVolumesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVolumesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVolumesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVolumesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVolumesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchVolumesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchVolumesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchVolumesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &WatchRequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchVolumesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchVolumesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchVolumesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddedShards = append(m.AddedShards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMonitor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMonitor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddedShards = append(m.AddedShards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedShards", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemovedShards = append(m.RemovedShards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMonitor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMonitor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemovedShards = append(m.RemovedShards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedShards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MonitorResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (VolumeState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedShards", wireType)
			}
			m.RequestedShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedShards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CurrentShards = append(m.CurrentShards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMonitor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMonitor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CurrentShards = append(m.CurrentShards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentShards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitorResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitorResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitorResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchRequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRevision", wireType)
			}
			m.StartRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRevision |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMonitor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMonitor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMonitor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMonitor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMonitor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMonitor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMonitor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMonitor   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("monitor.proto", fileDescriptor_monitor_4b8c2940e2de8636) }

var fileDescriptor_monitor_4b8c2940e2de8636 = []byte{
	// 1132 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x16, 0x45, 0x7d, 0x8e, 0x6c, 0x45, 0xef, 0xca, 0x1f, 0x8a, 0x82, 0xd7, 0x49, 0x09, 0xa4,
	0x75, 0x53, 0xc0, 0x76, 0x15, 0x24, 0x28, 0x7a, 0x29, 0x2c, 0x5b, 0xfe, 0x68, 0x62, 0xa3, 0x58,
	0xf5, 0x03, 0xed, 0x45, 0xd8, 0x88, 0x2b, 0x69, 0x11, 0x8a, 0x54, 0x76, 0xd7, 0x82, 0x1d, 0xa0,
	0x40, 0xff, 0x41, 0xae, 0xbd, 0xf6, 0xda, 0x43, 0x7f, 0x47, 0x8f, 0xfd, 0x09, 0x85, 0xfb, 0x47,
	0x0a, 0xee, 0xae, 0x28, 0x92, 0x22, 0x7a, 0xa8, 0x91, 0xde, 0xb8, 0xf3, 0xcc, 0x3c, 0x3b, 0xcf,
	0x70, 0x34, 0x43, 0xc1, 0xfa, 0x34, 0xf0, 0x99, 0x0c, 0xf8, 0xde, 0x8c, 0x07, 0x32, 0x40, 0x36,
	0x99, 0x31, 0x67, 0x1b, 0x36, 0x8f, 0x3c, 0x46, 0x7d, 0xd9, 0xa7, 0x52, 0x32, 0x7f, 0x2c, 0x30,
	0x7d, 0x73, 0x45, 0x85, 0x74, 0x7e, 0x84, 0xad, 0x34, 0x20, 0x66, 0x81, 0x2f, 0x28, 0xea, 0x40,
	0x69, 0x42, 0x89, 0x4b, 0x79, 0xcb, 0x7a, 0x64, 0xed, 0xd6, 0x3a, 0xed, 0x3d, 0x32, 0x63, 0x7b,
	0x17, 0x9a, 0x7b, 0xe1, 0x75, 0xa6, 0x3c, 0xb0, 0xf1, 0x44, 0xfb, 0x50, 0x11, 0x86, 0xa7, 0x95,
	0x57, 0x51, 0x4d, 0x15, 0x95, 0xba, 0x22, 0x72, 0x72, 0xde, 0xe5, 0xa1, 0x9e, 0x04, 0x91, 0x03,
	0xeb, 0x53, 0xe6, 0x0f, 0x46, 0xcc, 0xf3, 0x06, 0x82, 0xbd, 0xa5, 0xea, 0xfa, 0x22, 0xae, 0x4d,
	0x99, 0x7f, 0xc2, 0x3c, 0xaf, 0xcf, 0xde, 0x52, 0xb4, 0x0f, 0xd5, 0x09, 0x11, 0x93, 0x01, 0xf1,
	0xc6, 0x81, 0xba, 0xa8, 0xde, 0x41, 0xea, 0xa2, 0x33, 0x22, 0x26, 0x87, 0xde, 0x38, 0xe0, 0x4c,
	0x4e, 0xa6, 0xb8, 0x32, 0x31, 0x47, 0x74, 0x00, 0x45, 0x4e, 0x5e, 0x31, 0xbf, 0x65, 0xab, 0xac,
	0x5a, 0xca, 0x19, 0x87, 0x96, 0xa3, 0xc9, 0x95, 0xff, 0x3a, 0x0a, 0x39, 0xcb, 0x61, 0xed, 0x18,
	0x46, 0x8c, 0xd8, 0x35, 0x75, 0x5b, 0x85, 0x58, 0xc4, 0x49, 0x68, 0x59, 0x8d, 0x50, 0x8e, 0xe8,
	0x39, 0x94, 0x47, 0x44, 0xc8, 0xa1, 0x3b, 0x6c, 0x15, 0x63, 0x15, 0x3b, 0x21, 0x42, 0x1e, 0x1d,
	0x1f, 0xad, 0x44, 0x2d, 0x9c, 0xbb, 0x6b, 0x00, 0xc3, 0x10, 0x54, 0x6a, 0x9c, 0x01, 0x34, 0x33,
	0xf2, 0x42, 0x08, 0x0a, 0xb3, 0xc0, 0xbb, 0x51, 0xc5, 0x28, 0x60, 0xf5, 0x8c, 0xee, 0x43, 0x65,
	0x4a, 0xae, 0x75, 0x91, 0xf2, 0xaa, 0x48, 0xe5, 0x29, 0xb9, 0x56, 0x05, 0x0a, 0x21, 0xe6, 0x6b,
	0xc8, 0x36, 0x10, 0xf3, 0x43, 0xc8, 0x39, 0x80, 0x66, 0x86, 0x8c, 0x04, 0x99, 0x95, 0x20, 0x73,
	0x26, 0xb0, 0x99, 0x29, 0xe2, 0x1f, 0x62, 0x12, 0x09, 0xe4, 0x13, 0x09, 0x84, 0x10, 0x99, 0x8f,
	0x13, 0xb9, 0x91, 0xf9, 0x58, 0xdd, 0xb4, 0x0d, 0x9b, 0x7d, 0xca, 0xe7, 0x94, 0x67, 0xb4, 0x69,
	0x1a, 0x78, 0x0f, 0x6d, 0x9a, 0xba, 0x62, 0xd9, 0xa6, 0x23, 0xa8, 0x27, 0x31, 0xf4, 0x7f, 0x00,
	0x31, 0x21, 0xdc, 0x5d, 0x8a, 0xb7, 0x71, 0x55, 0x59, 0x94, 0xc6, 0x67, 0xb0, 0xad, 0x61, 0xea,
	0x4b, 0xce, 0xa8, 0x18, 0xcc, 0x28, 0x1f, 0x08, 0x8f, 0x0d, 0x17, 0xd5, 0xd8, 0x50, 0x70, 0x4f,
	0xa3, 0x5f, 0x51, 0xde, 0x0f, 0xb1, 0x50, 0xff, 0x29, 0x95, 0x5d, 0x2f, 0x18, 0xbe, 0xee, 0xcb,
	0x80, 0xd3, 0x48, 0xff, 0x1c, 0xb6, 0xd2, 0xc0, 0x1d, 0xf4, 0xef, 0x42, 0xc1, 0x25, 0x92, 0x18,
	0xed, 0x1b, 0x2a, 0xe2, 0x32, 0x70, 0x29, 0xa6, 0x33, 0x8f, 0x0d, 0x49, 0x9f, 0x4a, 0x81, 0x95,
	0x87, 0x49, 0xe8, 0xdc, 0x77, 0xe9, 0x75, 0x56, 0x42, 0x09, 0xe0, 0x3f, 0x49, 0xe8, 0x73, 0xb8,
	0x97, 0x02, 0xd0, 0x47, 0x50, 0x10, 0x54, 0x8a, 0x96, 0xf5, 0xc8, 0x8e, 0xde, 0x64, 0xd2, 0x07,
	0x2b, 0x07, 0xe7, 0x53, 0xa8, 0x27, 0xed, 0xe8, 0x21, 0x14, 0xfd, 0xc0, 0xa5, 0x8b, 0xd8, 0xea,
	0x32, 0x56, 0xdb, 0x9d, 0x4b, 0x28, 0x84, 0x47, 0xd4, 0x82, 0x32, 0x71, 0x5d, 0x4e, 0x85, 0x50,
	0xaa, 0xaa, 0x78, 0x71, 0x0c, 0x7f, 0x98, 0x3e, 0x99, 0xea, 0xd7, 0x5a, 0xc5, 0xea, 0x39, 0xf4,
	0x9e, 0x71, 0x36, 0x25, 0xfc, 0x46, 0x35, 0x78, 0x05, 0x2f, 0x8e, 0x4e, 0x13, 0xfe, 0x77, 0x4a,
	0xe5, 0xb7, 0x81, 0x77, 0x35, 0x5d, 0xd6, 0x32, 0x00, 0x14, 0x37, 0xde, 0xa1, 0x8e, 0x8f, 0xa1,
	0x3c, 0xd7, 0x34, 0xad, 0xbc, 0x52, 0x54, 0x53, 0x41, 0x9a, 0x1a, 0x2f, 0x30, 0xe7, 0x10, 0x9a,
	0x17, 0x81, 0xcb, 0x46, 0x37, 0x06, 0xd0, 0x79, 0x44, 0x52, 0xac, 0x98, 0x94, 0x2d, 0x28, 0xa9,
	0x4e, 0xd5, 0x3f, 0x14, 0x1b, 0x9b, 0x93, 0xf3, 0x25, 0x6c, 0x24, 0x29, 0xfe, 0x7d, 0xd6, 0xce,
	0x09, 0x34, 0xbf, 0x23, 0x72, 0x38, 0x49, 0x96, 0x05, 0xed, 0xa7, 0xa8, 0xb6, 0x15, 0x95, 0xf2,
	0x34, 0x2e, 0x29, 0x9e, 0x37, 0xb0, 0x91, 0xe4, 0x79, 0xff, 0x95, 0xfc, 0xc9, 0x82, 0xe6, 0x37,
	0x33, 0x97, 0x48, 0xda, 0x57, 0x75, 0x59, 0xe4, 0xfe, 0x10, 0x6a, 0xda, 0x65, 0x10, 0xab, 0x28,
	0x68, 0xd3, 0x65, 0x58, 0xd7, 0x0f, 0x60, 0x8d, 0xb8, 0x2e, 0x75, 0x07, 0x51, 0x75, 0xed, 0x5d,
	0x1b, 0xd7, 0x94, 0x4d, 0x53, 0xa1, 0xc7, 0x50, 0xe7, 0x74, 0x1a, 0xcc, 0x97, 0x4e, 0xb6, 0x72,
	0x5a, 0x37, 0xd6, 0x7e, 0xf4, 0x26, 0x92, 0x19, 0xdc, 0xe1, 0x4d, 0xfc, 0x66, 0x41, 0x49, 0x4b,
	0xcc, 0x6c, 0x86, 0x0f, 0xa1, 0x28, 0x24, 0x91, 0xd4, 0xac, 0xdc, 0x46, 0xac, 0x24, 0xfd, 0xd0,
	0x8e, 0x35, 0x1c, 0x6b, 0x1a, 0x3b, 0xde, 0x34, 0xe8, 0x63, 0x68, 0x70, 0x5d, 0xa0, 0xa5, 0xa6,
	0x82, 0xf2, 0xb8, 0x17, 0xd9, 0x97, 0xe2, 0x87, 0x57, 0x9c, 0x53, 0x5f, 0x2e, 0x1c, 0x8b, 0x5a,
	0xbc, 0xb1, 0x1a, 0xf1, 0x23, 0xd8, 0xcc, 0x54, 0x84, 0xda, 0x50, 0xe1, 0x74, 0xce, 0x04, 0x0b,
	0x7c, 0x33, 0x9d, 0xa3, 0x33, 0xda, 0x80, 0x22, 0xe5, 0x3c, 0xe0, 0x66, 0x14, 0xeb, 0x03, 0x7a,
	0x00, 0x55, 0xf5, 0x30, 0x98, 0x8a, 0xb1, 0xca, 0xbb, 0x8a, 0x2b, 0xca, 0x70, 0x21, 0xc6, 0xce,
	0x05, 0xa0, 0xd5, 0xc6, 0x0b, 0x93, 0x14, 0x92, 0x70, 0x39, 0x48, 0x5d, 0xb5, 0xae, 0xac, 0x78,
	0x71, 0x5f, 0x03, 0x6c, 0xea, 0xbb, 0xea, 0xb6, 0x0a, 0x0e, 0x1f, 0x9f, 0x7c, 0x02, 0xeb, 0x89,
	0x2f, 0x15, 0x04, 0x50, 0xea, 0x9f, 0x1d, 0x76, 0x9e, 0x3d, 0x6f, 0xe4, 0x50, 0x1d, 0xa0, 0xfb,
	0xf2, 0xf0, 0x45, 0xaf, 0xd3, 0x0d, 0xcf, 0xd6, 0x93, 0xa7, 0x50, 0x8b, 0xd5, 0x18, 0xad, 0x41,
	0x05, 0xf7, 0xfa, 0xe7, 0x3f, 0x9c, 0x5f, 0x9e, 0x36, 0x72, 0xa8, 0x0a, 0x45, 0xdc, 0x3b, 0x3c,
	0xfe, 0xbe, 0x61, 0xa1, 0x1a, 0x94, 0x8f, 0x7b, 0x2f, 0x7b, 0x5f, 0xf7, 0x8e, 0x1b, 0xf9, 0xce,
	0xaf, 0x16, 0x54, 0xa2, 0x65, 0x75, 0xa9, 0xa6, 0x4e, 0xea, 0x3b, 0xab, 0x9d, 0xf5, 0x65, 0xa6,
	0xe5, 0xb5, 0x1f, 0x64, 0x62, 0xba, 0xc0, 0x4e, 0xce, 0xf0, 0xa5, 0x36, 0x62, 0x3b, 0x6b, 0x85,
	0x26, 0xf8, 0xb2, 0x37, 0xb8, 0x93, 0xeb, 0xfc, 0x62, 0x41, 0x31, 0x1c, 0xb3, 0x02, 0xbd, 0x80,
	0x7a, 0x72, 0xcf, 0x19, 0xda, 0xcc, 0xad, 0x68, 0x68, 0xb3, 0x17, 0xa3, 0x93, 0x33, 0x64, 0xb1,
	0x1d, 0xb5, 0x24, 0x5b, 0xdd, 0x68, 0x4b, 0xb2, 0x8c, 0xa5, 0xe6, 0xe4, 0x3a, 0xef, 0xf2, 0x50,
	0x36, 0x83, 0x05, 0x7d, 0x06, 0xf6, 0x29, 0x95, 0x68, 0x6b, 0x11, 0x91, 0x1c, 0x5c, 0xed, 0xed,
	0x15, 0x7b, 0x94, 0xd2, 0x17, 0x50, 0xd2, 0x63, 0x13, 0xb5, 0xcc, 0xcf, 0x71, 0x65, 0x0c, 0xb7,
	0xef, 0x67, 0x20, 0x11, 0x41, 0x17, 0x8a, 0xaa, 0x11, 0x4d, 0x7c, 0xc6, 0xdc, 0x34, 0xf1, 0x59,
	0x93, 0xd0, 0xc9, 0xed, 0x5a, 0x07, 0x16, 0xea, 0xc1, 0x5a, 0x7c, 0x62, 0x18, 0xaa, 0x8c, 0x31,
	0x66, 0xa8, 0xb2, 0xc6, 0x8b, 0x93, 0xeb, 0x36, 0x7e, 0xbf, 0xdd, 0xb1, 0xfe, 0xb8, 0xdd, 0xb1,
	0xfe, 0xbc, 0xdd, 0xb1, 0x7e, 0xfe, 0x6b, 0x27, 0xf7, 0xaa, 0xa4, 0xfe, 0x71, 0x3c, 0xfd, 0x3b,
	0x00, 0x00, 0xff, 0xff, 0x80, 0x71, 0x33, 0xfd, 0x82, 0x0c, 0x00, 0x00,
}
